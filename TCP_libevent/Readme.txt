libevent是一个用C语言写的开源的一个库。它对socket编程里的epoll/select等功能进行了封装，并且使用了一些设计模式（比如反 应堆模式），用事件机制来简化了socket编程。libevent的好处网上有很多，但是初学者往往都看不懂。我打个比方吧， 1） 假设有N个客户端同时往服务端通过socket写数据，用了libevent之后，你的server程序里就不用再使用epoll或是select来判断 都哪些socket的缓冲区里已经收到了客户端写来的数据。当某个socket的缓冲区里有可读数据时，libevent会自动触发一个“读事件”，通过 这个“读事件”来调用相应的代码来读取socket缓冲区里的数据即可。换句话说，libevent自己调用select()或是epoll的函数来判断 哪个缓冲区可读了，只要可读了，就自动调用相应的处理程序。 2） 对于“写事件”，libevent会监控某个socket的缓冲区是否可写（一般情况下，只要缓冲区没满就可写），只要可写，就会触发“写事件”，通过“写事件”来调用相应的函数，将数据写到socket里。

以上两个例子分别从“读”和“写”两方面简介了一下，可能不十分准确（但十分准确的描述往往会让人看不懂）。


=========关于libevent使用多线程的讨论=========================

网上很多资料说libevent不支持多线程，也有很多人说libevent可以支持多线程。究竟值不支持呢？我的答案是： 得看你的多线程是怎么写的，如何跟libevent结合的。

1）可以肯定的是，libevent的 信号事件 是不支持多线程的（因为源码里用了个全局变量）。可以看这篇文章（http://blog.csdn.net/sparkliang/article/details/5306809）。（注：libevent里有“超时事件”，“IO事件”，“信号事件”。）

2）对于不同的线程，使用不同的base，是可以的。

3）如果不同的线程使用相同的base呢？——如果在不同的线程里的事件都注册到同一个base上，会有问题吗？

（http://www.cnblogs.com/zzyoucan/p/3970578.html）这篇博客里提到说，不行！即使加锁也不行。我最近稍 微看了部分源码，我的答案是：不加锁会有并发问题，但如果对每个event_add()，event_del()等这些操作event的动作都用同一个临 界变量来加锁，应该是没问题的。——貌似也有点问题，如果某个事件没有用event_set()设置为EV_PERSIST，当事件发生时，会被自动删 除。有可能线程a在删除事件的时候，线程b却在添加事件，这样还是会出现并发问题。 最后的结论是——不行！ 。

========本次实验代码逻辑的说明==========================

我采取的方案是对于不同的线程，使用不同的base。——即每个线程对应一个base，将线程里的事件注册到线程的base上，而不是所有线程里的事件都用同一个base。

一 实验需求描述：
1）写一个client和server程序。多个client可以同时连接一个server；

2）client接收用户在标准输入的字符，发往server端；

3）server端收到后，再把收到的数据处理一下，返回给client；

4）client收到server返回的数据后，将其打印在终端上。

二 设计方案：
1. client：

1） client采用两个线程，主线程接收用户在终端上的输入，并通过socket将用户的输入发往server。

2） 派生一个子线程，接收server返回来的数据，如果收到数据，就打印出来。

2. server：

在主线程里监听client有没有连接连过来，如果有，立马accept出一个socket，并创建一个子线程，在子线程里接收client传过来的数据，并对数据进行一些修改，然后将修改后的数据写回到client端。
